CMD:pg ISOLATION:READ COMMITTED

[SQL]
-- NORMAL, DELAY BEFORE READ --
SELECT (pg_sleep(N)::text != '')::int;
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: UPDATE 1
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: UPDATE 0
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
B: COMMIT
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:REPEATABLE READ

[SQL]
-- NORMAL, DELAY BEFORE READ --
SELECT (pg_sleep(N)::text != '')::int;
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: UPDATE 1
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
B: ERROR:  could not serialize access due to concurrent update
A: COMMIT
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:SERIALIZABLE

[SQL]
-- NORMAL, DELAY BEFORE READ --
SELECT (pg_sleep(N)::text != '')::int;
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

B: BEGIN
A: BEGIN
B: SET
A: SET
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: UPDATE 1
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
B: ERROR:  could not serialize access due to concurrent update
A: COMMIT
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:READ COMMITTED

[SQL]
-- NORMAL, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT (pg_sleep(N)::text != '')::int)+remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

B: BEGIN
B: SET
A: BEGIN
A: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: UPDATE 0
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
B: COMMIT
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:REPEATABLE READ

[SQL]
-- NORMAL, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT (pg_sleep(N)::text != '')::int)+remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:SERIALIZABLE

[SQL]
-- NORMAL, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT (pg_sleep(N)::text != '')::int)+remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
B: BEGIN
A: SET
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:READ COMMITTED

[SQL]
-- NORMAL, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1+(SELECT (pg_sleep(N)::text != '')::int)
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

B: BEGIN
B: SET
A: BEGIN
A: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
B: UPDATE 0
A: COMMIT
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
B: COMMIT
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:REPEATABLE READ

[SQL]
-- NORMAL, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1+(SELECT (pg_sleep(N)::text != '')::int)
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:SERIALIZABLE

[SQL]
-- NORMAL, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1+(SELECT (pg_sleep(N)::text != '')::int)
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY WHERE, DELAY BEFORE READ --
SELECT (pg_sleep(N)::text != '')::int;
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

B: BEGIN
B: SET
A: BEGIN
A: SET
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: UPDATE 1
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: UPDATE 1
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
B: COMMIT
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |               -1 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY WHERE, DELAY BEFORE READ --
SELECT (pg_sleep(N)::text != '')::int;
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

B: BEGIN
B: SET
A: BEGIN
A: SET
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: UPDATE 1
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY WHERE, DELAY BEFORE READ --
SELECT (pg_sleep(N)::text != '')::int;
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

B: BEGIN
B: SET
A: BEGIN
A: SET
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: UPDATE 1
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY WHERE, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT (pg_sleep(N)::text != '')::int)+remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
B: UPDATE 1
A: COMMIT
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
B: COMMIT
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |               -1 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY WHERE, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT (pg_sleep(N)::text != '')::int)+remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
B: ERROR:  could not serialize access due to concurrent update
A: COMMIT
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY WHERE, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT (pg_sleep(N)::text != '')::int)+remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY WHERE, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=+remaining_amount, remaining_amount=remaining_amount-1+(SELECT (pg_sleep(N)::text != '')::int)
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

B: BEGIN
B: SET
A: BEGIN
A: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
B: UPDATE 1
A: COMMIT
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
B: COMMIT
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |               -1 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY WHERE, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=+remaining_amount, remaining_amount=remaining_amount-1+(SELECT (pg_sleep(N)::text != '')::int)
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY WHERE, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=+remaining_amount, remaining_amount=remaining_amount-1+(SELECT (pg_sleep(N)::text != '')::int)
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY SET, DELAY BEFORE READ --
SELECT (pg_sleep(N)::text != '')::int;
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
B: BEGIN
B: SET
A: SET
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: UPDATE 1
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: UPDATE 0
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
B: COMMIT
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY SET, DELAY BEFORE READ --
SELECT (pg_sleep(N)::text != '')::int;
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: UPDATE 1
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY SET, DELAY BEFORE READ --
SELECT (pg_sleep(N)::text != '')::int;
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: UPDATE 1
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY SET DELAY ON PRE-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT (pg_sleep(N)::text != '')::int)+(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

B: BEGIN
A: BEGIN
B: SET
A: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: UPDATE 0
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
B: COMMIT
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY SET DELAY ON PRE-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT (pg_sleep(N)::text != '')::int)+(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ROLLBACK
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY SET DELAY ON PRE-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT (pg_sleep(N)::text != '')::int)+(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
B: BEGIN
A: SET
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY SET DELAY ON POST-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1+(SELECT (pg_sleep(N)::text != '')::int)
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: UPDATE 0
B:  int4 
B: ------
B:     0
B: (1 row)
B: 
B: COMMIT
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY SET DELAY ON POST-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1+(SELECT (pg_sleep(N)::text != '')::int)
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

A: BEGIN
A: SET
B: BEGIN
B: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:pg ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY SET DELAY ON POST-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1+(SELECT (pg_sleep(N)::text != '')::int)
WHERE id=1 AND remaining_amount>0;
SELECT (pg_sleep(0)::text != '')::int;

 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                1 |                    1 |                    0
(1 row)

B: BEGIN
B: SET
A: BEGIN
A: SET
A: UPDATE 1
A:  int4 
A: ------
A:     0
A: (1 row)
A: 
A: COMMIT
B: ERROR:  could not serialize access due to concurrent update
B: ERROR:  current transaction is aborted, commands ignored until end of transaction block
B: ROLLBACK
 id | remaining_amount | referencing_amount_a | referencing_amount_b 
----+------------------+----------------------+----------------------
  1 |                0 |                    1 |                    0
(1 row)

UPDATE 1

CMD:my ISOLATION:READ UNCOMMITTED

[SQL]
-- NORMAL, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ COMMITTED

[SQL]
-- NORMAL, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:REPEATABLE READ

[SQL]
-- NORMAL, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:SERIALIZABLE

[SQL]
-- NORMAL, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ UNCOMMITTED

[SQL]
-- NORMAL, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT sleep(N))+remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ COMMITTED

[SQL]
-- NORMAL, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT sleep(N))+remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:REPEATABLE READ

[SQL]
-- NORMAL, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT sleep(N))+remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:SERIALIZABLE

[SQL]
-- NORMAL, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT sleep(N))+remaining_amount, remaining_amount=remaining_amount-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ UNCOMMITTED

[SQL]
-- NORMAL, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1+(SELECT sleep(N))
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ COMMITTED

[SQL]
-- NORMAL, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1+(SELECT sleep(N))
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:REPEATABLE READ

[SQL]
-- NORMAL, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1+(SELECT sleep(N))
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:SERIALIZABLE

[SQL]
-- NORMAL, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1+(SELECT sleep(N))
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ UNCOMMITTED

[SQL]
-- SUBQUERY WHERE, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY WHERE, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	-1	1	0

CMD:my ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY WHERE, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	0
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	0

CMD:my ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY WHERE, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET referencing_amount_%%USER%%=remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	0
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	0

CMD:my ISOLATION:READ UNCOMMITTED

[SQL]
-- SUBQUERY WHERE, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT sleep(N))+remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	0
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	-1	1	0

CMD:my ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY WHERE, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT sleep(N))+remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	0
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	-1	1	0

CMD:my ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY WHERE, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT sleep(N))+remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	0
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY WHERE, DELAY ON PRE-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=(SELECT sleep(N))+remaining_amount, remaining_amount=remaining_amount-1
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ UNCOMMITTED

[SQL]
-- SUBQUERY WHERE, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=+remaining_amount, remaining_amount=remaining_amount-1+(SELECT sleep(N))
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	-1	1	0

CMD:my ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY WHERE, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=+remaining_amount, remaining_amount=remaining_amount-1+(SELECT sleep(N))
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	0
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	-1	0	1

CMD:my ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY WHERE, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=+remaining_amount, remaining_amount=remaining_amount-1+(SELECT sleep(N))
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	0	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY WHERE, DELAY ON POST-WRITE --
UPDATE products
SET referencing_amount_%%USER%%=+remaining_amount, remaining_amount=remaining_amount-1+(SELECT sleep(N))
WHERE EXISTS(
  SELECT * FROM (
    SELECT * FROM products WHERE id=1 AND remaining_amount>0
  ) tmp
);
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ UNCOMMITTED

[SQL]
-- SUBQUERY SET, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY SET, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY SET, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY SET, DELAY BEFORE READ --
SELECT sleep(N);
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(1)
A: 0
A: sleep(2)
A: 0
B: sleep(2)
B: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ UNCOMMITTED

[SQL]
-- SUBQUERY SET DELAY ON PRE-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT sleep(N))+(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY SET DELAY ON PRE-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT sleep(N))+(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY SET DELAY ON PRE-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT sleep(N))+(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY SET DELAY ON PRE-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT sleep(N))+(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ UNCOMMITTED

[SQL]
-- SUBQUERY SET DELAY ON POST-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1+(SELECT sleep(N))
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:READ COMMITTED

[SQL]
-- SUBQUERY SET DELAY ON POST-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1+(SELECT sleep(N))
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
A: sleep(2)
A: 0
B: sleep(0)
B: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:REPEATABLE READ

[SQL]
-- SUBQUERY SET DELAY ON POST-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1+(SELECT sleep(N))
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

CMD:my ISOLATION:SERIALIZABLE

[SQL]
-- SUBQUERY SET DELAY ON POST-WRITE --
UPDATE products
SET
  referencing_amount_%%USER%%=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp1),
  remaining_amount=(SELECT remaining_amount FROM (SELECT * FROM products WHERE id=1) tmp2)-1+(SELECT sleep(N))
WHERE id=1 AND remaining_amount>0;
SELECT sleep(0);

id	remaining_amount	referencing_amount_A	referencing_amount_B
1	1	1	1
B: sleep(0)
B: 0
A: sleep(2)
A: 0
id	remaining_amount	referencing_amount_A	referencing_amount_B
1	0	1	1

